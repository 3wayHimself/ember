<h1>Dime Developement Methodology</h1>

<h2>Abstract</h2>

This document presents a set of rules that we strive to follow in the Dime effort.
They are mostly adapted from the Extreme Programming methodology.

<h2>Change History</h2>

2002-02-11 zzorn First version<br />
2002-02-12 zzorn Some clarifications, added a lot of questions.<br />


<h2>Related Discussions</h2>
<a href="http://brenda.worldforge.org:8080/logs/info.php?file=dime200202111926.irc#line297">2002-02-11 19:26 Preparing the start of Dime iteration 2, ideas for how to apply XP to dime.</a>

<h2>External Resources</h2>

<ul>
  <li><a href="http://www.extremeprogramming.org">Introduction to XP</a></li>
	<li><a href="http://www.extremeprogramming.org/rules.html">XP Rules</a></li>
</ul>

<h2>Introduction</h2>

We use some of the rules of Extreme Programming that are suitable for distributed 
Free Software/Open Source projects.

<h2>Rules</h2>

<h3>Coding Standard</h3>
<ul>
  <li>We use a common coding standard to make it easier for developers to 
	understand each others code.</li>
	<li>There is a template header file that also specifies the coding style in the <tt>forge/clients/dime/doc</tt> 
	folder in cvs. <span class="todo">TODO: Move to separate coding standard document.</span></li>
	<li>We also document the code with JavaDoc (or Doxygen) syntax, and generate the API documentation
	for it automatically.</li>
</ul>

<h3>Unit Testing</h3>
<ul>
  <li>Unit tests are written before and during the implementation.</li>
  <li>We use <a href="http://cppunit.sourceforge.net/">cppunit</a> as a support library for writing the unit tests.</li>
  <li>Unit tests should pass before code is committed.</li>
</ul>

<h3>Customer</h3>
<ul>
  <li>XP relies on an always present customer.  In the case of OS/FS it seems that the developers are often their own customers.</li>
	<li>We could see the project meetings as the 'customer', and prioritize and decide features in them.</li>
	<li>We could alternatively / also appoint one or more persons to represent the customer?</li>
</ul>

<h3>Stories</h3>
<ul>
  <li>Represent features desired by the customer.  The feature is described with just a few lines of text to make it possible to 
	    create a rough time estimate and priority for it.</li>
	<li>Each story has an estimate of needed developement time, estimated by the developers.  [in what units?]</li>
	<li>Each story also has a priority assigned by the customer.</li>
	<li>It seems that this might not be the easiest way to handle things in a distributed project.  Perhaps
	just feature listings with priorities and possibly effort estimates collected at
	planning meetings could work.</li>
	<li>Do we need separatate large stories/features and detailed tasks?  It cantake a lot of time to divide stuff into tasks (XP does this after using CRC cards to design it?)</li>
	<li>Is there any anology for CRC based design in distributed projects?  IRC brainstorming, with a secretary?  Should we design each feature together, splitting it up approximately into classes?</li>
	<li>Letting the developers pick features to implement is of course important.  The developer
	that selects a task / feature should assign him/herself to it in RT (?) and provide a time / effort estimate
	for the task, and update the RT entry when the task is done.</li>
</ul>

<h3>Tasks</h3>
<ul>
  <li>Tasks are more well defined parts of stories, that equal around 1-3 days (?) of 
  ideal developer time.</li>
  <li>Tasks are kept in the WF request tracker database.</li>
</ul>

<h3>Iterative Development</h3>
<ul>
  <li>The project is divided into iterations.  Each iteration shold be short (2-3 weeks).</li>
	<li>A set of tasks to implement in an iteration are selected in the Iteration Planning meeting.  
	The total effort of stories that can be implemented depends on how much we got implemented in the 
	previous iteration.</li>
	<li>An iteration should result in a new set of working features (Hmm.. or was that a release??) </li>
</ul>

<h3>Releases</h3>
<ul>
  <li>A release is bigger than an iteration.  It contains a subset of the total functionality.</li>
	<li>The features to implement in a release are agreed on in a Release Planning Meeting.  If necessary,
	new Release Planning Meetings are held to re-evaluate the list of features to be implemented for the release. </li>
</ul>

<h3>Collecting Project Metrics</h3>
<ul>
  <li>Calculating the project velocity makes it possibly to more reliably estimate how many
	and complicated features we can implement in an iteration or release.</li>
	<li>We don't have deadlines in the sense of commercial projects.  Does it still make sense
	to try to predict the progress?</li>
	<li>Collecting the project metrics can be a time consuming task, that possibly doesn't directly 
	help development.  Thus it should be automated as much as possible (this automation should be abstracted
	and implemented forthe new website too).  Working on the automation is a task related 
	to website development.</li>
</ul>
         <br /><br />
    </td>
  </tr>
</table>
