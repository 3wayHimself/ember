<h1>Dime Design Document</h1>

<h2>Abstract</h2>
<p>
This document describes the internal architecture of Dime. <br />
It explains the purpose of services, the central data model,
components, scripts, and interface layouts. 
</p>

<h2>Version History</h2>

<table class="chart">
<tr>
<th>Version</th>
<th>Date</th>
<th>Author</th>
<th>Nick</th>
<th>Changes</th>
</tr>

<tr>
<td>0.1</td>
<td>2002-02-03</td>
<td>Hans Häggström</td>
<td>zzorn</td>
<td>Initial version based on IRC discussions.</td>
</tr>

</table>

<h2>Introduction</h2>

<p>
The overall Dime architecture generally follows a Model-View-Controller (MVC) pattern. 
It is also based on application framework pattern ideas.
The figure below shows an overview of the different parts of the dime architecture.
</p>

<p>
<table cellpadding="4" cellspacing="0">
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="4" bgcolor="#ff99ff"><center>Interface Layouts</center></td>
  </tr>
  <tr>
    <td colspan="1" bgcolor="#ffcc99"><center>Scripts</center></td>
    <td colspan="3" bgcolor="#ffff99"><center>Components</center></td>
  </tr>
  <tr>
    <td colspan="2" bgcolor="99ff99"><center>Central Data Model</center></td>
    <td bgcolor="#ffff99"></td>
    <td bgcolor="#ffff99"></td>
  </tr>
  <tr>
    <td colspan="3" bgcolor="#99ccff"><center>Services</center></td>
    <td bgcolor="#ffff99"></td>
  </tr>
  <tr>
    <td colspan="4" bgcolor="#9999ff"><center>External Libraries</center></td>
  </tr>
</table>
<b>Dime architecture.</b>
</p>

<h2>Services</h2>

<p>The services take care of low level interaction with the game server, the 
clients system (sound, input, etc), and so on.  These can be used directly by 
components, and indirectly by scripts through those properties and functionality 
that the services publish in the central data model.
</p>

<h2>Central Data Model</h2>

<p>The Central Data Model is a tree of DataObjects that contains various information about the 
game, the client, available servers, and so on.     
For example, we keep a list of the different actions, 
properties, and various streams (like incoming and outgoing speech) associated with 
each active avatar in the data model.
We can then query the central data model for what actions the avatar can do in what circumstance, 
what actions the avatar can do to different objects, what the health of the avatar is, and so on.
</p>
<p>
Data intensive things, like querying terrain information and entity positions 
from game views, are done directly from the low level services or utility libraries,
and doesn't happen through the central data model.  The central data model might still
provide lists of nearby entities for example to scripts and components that could be interested.
</p>

<h2>Components</h2>

<p>
Basically a component is a building block of the interface and the functionality 
of the client.  It's not a low level service, and it's used commonly enough and
requires enough coding, or needs access to low level services, so that it is not 
ideal to implement as a script.
</p>
<p>
There are various components, that range from simple general purpose widgets 
(gauges, buttons, etc), to more specialized ones (chat window, inventory screen, etc).
Many of these have views, although some are not visible (for example sound 'view'
type components that play sound effects for events in the game world, and 
utility components that process information for other components).  The component 
instances loosely represent the view part of the MVC pattern.
Each component instance also has its own data model, containing properties and
actions that the component provides or can be configured with.  This 
interface layouts to connect it to other components, the central data model, or
scripts. 
</p>
<p>
Game views are a subclass of components, and are thus treated as any other 
component with a visible widget.
So it is possible to use multiple game views even at the same time, for example having 
a 2D overview of the map, and a 3D view of the character from above.
</p>


<h2>Scripts</h2>
<p>
It is also possible to create scripts that allow more complicated control over 
behavior of the user interface and character.
It will be possible to use data models and objects from a scripting language.  
That way we only have to implement a little code, to allow scripts to interact 
with all the data and functionality in the central data model and data models 
provided by components.
Some candidates for scripting languages are python and lua.
We can implement multiple scripting language bindigs also.
</p>
<p>
It could also be possible to implement a security model that would allow the 
user to specify what scripts have accoss to what parts of the central data model,
or which components they can create and use, and wether they have read/write or
read only access.
</p>


<h2>Interface Layouts</h2>
<p>
The controller part, that maps input and output from the model and different 
components to each other, consists of dynamic connections specified in one or 
more Interface Layout files that are loaded at startup, or can eventually be 
edited by power users in-game.
Interface Layout files are not in a real scripting language, they just contain 
instructions of what components to create, where to place them, and how to connect 
their data models with the central data model.  Interface Layout files can also 
create script instances in a similar way, from registered / installed scripts.
A visual editor that allows (mainly expert) users to edit interface layouts
directly in the client will be implemented eventually.  
</p>
<p>
Different games will need different interface layouts, specialized for that game.
Expert users can also create their own interfaces, tuned to different tastes
and providing different functionality, and share them through the media repository
with other users.
</p>
<p>
Interface Layouts can be changed on run time too, and different parts of the 
UI can use different interfac layouts.  For example switching between full 
screen view and a view with a GUI could be done by changing the interface layout
for the whole screen.  When the avatar uses some vehicle in-game (or other type 
of control interface that provides it's own properties (fuel gauge, speed gauge), 
actions, and other data objects) a special interface for it could be added to
the current UI, or partly replace the current UI.
</p>

<br />
<br />


      <br /><br />
    </td>
  </tr>
</table>
