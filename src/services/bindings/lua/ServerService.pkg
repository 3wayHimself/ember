


namespace Ember {


class ServerService 
{
	Eris::Connection* getConnection();


    bool isConnected() const;

    bool connect(const std::string& host, short port = 6767);

//    void reconnect();

    void disconnect();
	
    void takeCharacter(const std::string &id);

	bool createCharacter(const std::string& name, const std::string& sex, const std::string& type, const std::string& description);

	Eris::View* getView();
	Eris::Avatar* getAvatar();
      
	void moveToPoint(const WFMath::Point<3>& dest); 
	void moveInDirection(const WFMath::Vector<3>& velocity, const WFMath::Quaternion& orientation);
	void moveInDirection(const WFMath::Vector<3>& velocity);
	void say(const std::string &message);
	void touch(Eris::Entity* entity);
	/**
	 *    Emotes something.
	 * @param entity 
	 */
	void emote(const std::string& emote);
	void drop(Eris::Entity* entity, const WFMath::Vector<3>& offset = WFMath::Vector<3>(0,0,0));
	void place(Eris::Entity* entity, Eris::Entity* target);
	void wield(Eris::Entity* entity);
	void take(Eris::Entity* entity);
	/**
	 *    Uses the currently wielded entity on the supplied entity.
	 * @param entity The entity on which the currently wielded entity will be used.
	 * @param pos The position on the entity to perform the action. In some cases this won't matter, whereas in others (such as digging on the world entity) it will.
	 * @param operation The operation to perform. If left blank the default will be used.
	 */
	void use(Eris::Entity* entity, WFMath::Point<3> pos = WFMath::Point<3>(0,0,0), const std::string& operation = "");
	/**
	 *    Stops the current use operation.
	 */
	void useStop();
	
	void actuate(Eris::Entity* entity,  const std::string& action);	

	void attack(Eris::Entity* entity);
	void eat(Eris::Entity* entity);
	void deleteEntity(Eris::Entity* entity);
	void setAttributes(Eris::Entity* entity, Atlas::Message::MapType& attributes);

    //----------------------------------------------------------------------
	// Signals
	sigc::signal<void, Eris::Avatar*> GotAvatar;
	sigc::signal<void, Eris::View*> GotView;
	sigc::signal<void, Eris::Connection*> GotConnection;
	sigc::signal<void, Eris::Account*> GotAccount;
	sigc::signal<void, Eris::Account *> LoginSuccess;
	sigc::signal<void, Eris::Account *, const std::string &> LoginFailure;
	sigc::signal<void, const Atlas::Objects::Entity::RootEntity &> GotCharacterInfo;
	sigc::signal<void, Eris::Account *> GotAllCharacters;

	/**
	 * @brief Emitted when an object is about to be sent to the server.
	 */
	sigc::signal<void, const Atlas::Objects::Root&> EventSendingObject;

	/**
	 * @brief Emitted when an object has been received.
	 */
	sigc::signal<void, const Atlas::Objects::Root&> EventReceivedObject;

    //----------------------------------------------------------------------
    // Callbacks from Eris

};
}
