$#include "components/ogre/authoring/EntityRecipe.h"

namespace EmberOgre {
namespace Authoring {
/**
 * Resource that stores recipes for entity creator.
 */
class EntityRecipe : public Ogre::Resource {

public:
	EntityRecipe(Ogre::ResourceManager* creator, const Ogre::String& name, Ogre::ResourceHandle handle,
		const Ogre::String& group, bool isManual = false, Ogre::ManualResourceLoader* loader = 0);
	virtual ~EntityRecipe();
 	void loadImpl(void);
 	void unloadImpl(void);
	size_t calculateSize(void) const;
//	GUIAdapter* createGUIAdapter(const std::string& name, const std::string& type, const std::string& tooltip);
//	GUIAdapter* getGUIAdapter(const std::string& name);
	const GUIAdaptersStore& getGUIAdapters();
//	GUIAdapterBindings* createGUIAdapterBindings(const std::string& name);
	void setAuthor(const std::string& author);
	const std::string& getAuthor() const;
	void setDescription(const std::string& description);
	const std::string& getDescription() const;
	//void doTest();
	void createEntity(Eris::TypeService& typeService);
};

class EntityRecipePtr
{
public:
	EntityRecipe* get();
};

class GUIAdaptersStore
{
class value_type {
	const std::string& first;
	GUIAdapter* second;
};

$#define __operator_ptr operator*
$#define __operator_pp operator++

class const_iterator {
public:
    value_type& __operator_ptr @ get();
	EmberOgre::Authoring::GUIAdaptersStore::const_iterator& __operator_pp @ next();
	bool operator==(const EmberOgre::Authoring::GUIAdaptersStore::const_iterator& value);
};
public:
	EmberOgre::Authoring::GUIAdaptersStore::const_iterator begin() const;
	EmberOgre::Authoring::GUIAdaptersStore::const_iterator end @ theEnd() const;  // end is keyword in Lua
};
}
}

// Iterator over GUIAdaptersStore
$[
function EmberOgre.Authoring.GUIAdaptersStore:pairs()
  local I = self:begin()
  local Iend = self:theEnd()
  return function()
    if I ~= Iend then
      local val = I:get()
      I = I:next()
      return val.first, val.second
    end
  end
end
$]

#endif
