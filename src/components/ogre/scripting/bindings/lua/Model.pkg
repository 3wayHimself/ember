namespace EmberOgre {
namespace Model {
class Model
{
//	typedef std::map<std::string, Action> ActionStore;

//	typedef std::set<EmberOgre::SubModel*> SubModelSet;
//	typedef std::set<std::string> StringSet;
//	typedef std::map<std::string, StringSet > SubModelPartMapping;
//	typedef std::map<std::string, SubModelPart*> SubModelPartMap;


	/**
	 *    Creates a new Model instance with the specified name.
	 *    Remember to call create(...) to create the actual meshes.
	 * @param name 
	 * @return 
	 */
	Model(const std::string& name);
	
	
	/**
	 *    Creates a new Model instance.
	 *    The name of the model will be autogenerated.
	 *    Remember to call create(...) to create the actual meshes.
	 * @return 
	 */
	Model();
	
	
	/**
	 * Try to create the needed meshes from the specified modeldef.
	 * Returns true if successful, else false.
	 * @param modelType 
	 * @return 
	 */
	bool create(const std::string& modelType); // create model of specific type

	
	/**
	 *    Reloads the model from the modeldefinition.
	 */
	void reload();
	
	virtual ~Model();

	bool addSubmodel(EmberOgre::Model::SubModel* submodel);
 	bool removeSubmodel(EmberOgre::Model::SubModel* submodel);
 	
	EmberOgre::Model::Action* getAction(const std::string& name);	
	

	/**
	 * hides and shows a certain part of the model
	 */
	void showPart(const std::string& partName);
	void hidePart(const std::string& partName);
	void setVisible(bool visible);
	
	/**
	 * if defined in the modeldef, returns a scaler by which the node containing 
	 * the model can be scaled
	 */
	const Ogre::Real getScale() const;

	/**
	 * if defined in the modeldef, returns an amount of degrees by which the node containing 
	 * the model can be rotated
	 */
	const Ogre::Real getRotation() const;
	
	/**
	 * if defined in the modeldef, returns an axis by which the model can be scaled
	 * I.e. when dealing with something such as a fir tree, you want to use the
	 * height of the tree to determine how much it should be scaled, since the 
	 * bounding box supplied by eris doesn't take the branches into account
	 */
	const EmberOgre::Model::ModelDefinition::UseScaleOf getUseScaleOf() const;
	

        /** Overridden from MovableObject */
        virtual const std::string& getName(void) const;

        /** Overridden from MovableObject */
		
	/**
	 *    returns a pointer to the defintion of the Model
	 * @return 
	 */
	EmberOgre::Model::ModelDefnPtr getDefinition() const;
	
	
	bool hasAttachPoint(const std::string& attachPoint) const; 

//	const ParticleSystemBindingsPtrSet& getAllParticleSystemBindings() const;

//	ParticleSystemSet& getParticleSystems();
	
	bool hasParticles() const;

	//EmberOgre::Model::SubModel* getSubModel(const std::string& name);
	EmberOgre::Model::SubModel* getSubModel(unsigned int index);
	//std::set<EmberOgre::Model::SubModel*> getSubmodels() const;
//	std::map<std::string, EmberOgre::Model::SubModelPart*> getSubmodelParts() const;
};

}

}
