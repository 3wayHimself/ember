namespace EmberOgre {
namespace Model {

typedef std::vector<EmberOgre::Model::SubModelDefinition*> SubModelDefinitionsStore;
typedef std::vector<EmberOgre::Model::PartDefinition*> PartDefinitionsStore;
typedef std::vector<EmberOgre::Model::SubEntityDefinition*> SubEntityDefinitionsStore;


class SubEntityDefinition
{
	 std::string& getSubEntityName() ;
	//void setSubEntityName( std::string&);
	unsigned int getSubEntityIndex() ;

	 std::string& getMaterialName() ;
	void setMaterialName( std::string& materialName);
	EmberOgre::Model::PartDefinition& getPartDefinition();

};	


class PartDefinition
{
	void setName( std::string& name);
	 std::string& getName() ;
	
	void setShow(bool show);
	bool getShow() ;
	
	EmberOgre::Model::SubEntityDefinition* createSubEntityDefinition( std::string& subEntityName);
	EmberOgre::Model::SubEntityDefinition* createSubEntityDefinition(unsigned int subEntityIndex);
	std::vector<EmberOgre::Model::SubEntityDefinition*> getSubEntityDefinitions();
	void removeSubEntityDefinition(EmberOgre::Model::SubEntityDefinition* def);
	EmberOgre::Model::SubModelDefinition& getSubModelDefinition();
	
};


class SubModelDefinition
{
	
	 std::string& getMeshName() ;
	
	EmberOgre::Model::PartDefinition* createPartDefinition( std::string& partname);
	std::vector<EmberOgre::Model::PartDefinition*> getPartDefinitions();
	void removePartDefinition(EmberOgre::Model::PartDefinition* def);
	EmberOgre::Model::ModelDefinition& getModelDefinition();
};


class ModelDefinition : public Ogre::Resource {

	/**
	whether to use a certain axis for scaling
	for example, if you use a model of a human you probably want to scale according to the height
	this might mean that width and depths aren't correct though
	*/
	enum UseScaleOf {
		MODEL_ALL = 0,
		MODEL_NONE = 1,
		MODEL_WIDTH = 2,
		MODEL_DEPTH = 3,
		MODEL_HEIGHT = 4
	};

	/**
	A struct for simple bindings between areas and materials/textures.
	*/
	struct AreaDefinition
	{
		int Id;
		std::string TextureName;
		std::string MaterialName;
	};
	
 
    bool isValid(void);
	void setValid(bool valid);

	
	/**
	 *    Gets the amount of scale that needs to be applied to derived Models.
	 * @return 
	 */
	inline float getScale();
	inline void setScale(float scale);
	
	/**
	 *    Gets how derived Models needs to be scaled.
	 Defaults to "ALL"
	 * @return 
	 */
	inline  EmberOgre::Model::ModelDefinition::UseScaleOf getUseScaleOf();
	inline void setUseScaleOf( EmberOgre::Model::ModelDefinition::UseScaleOf useScale);
	
	/**
	 *    Gets an optional translation vector which should be applied to derived Models.
	 * @return 
	 */
	 Ogre::Vector3& getTranslate();
	void setTranslate( Ogre::Vector3 translate);
	
	/**
	 *	Whether contained entities should be shown or not.
	 Defaults to true.
	 * @return true if contained entities should be shown, else false
	 */
	bool getShowContained();
	void getShowContained(bool show);
	
	/**
	 *    Returns a vector defining how much, if ever, contained entities should be offset.
	 *    If they shouldn't, a void pointer will be returned.
	 * @return A offset vector or null.
	 */
	Ogre::Vector3* getContentOffset() ;
	void setContentOffset(Ogre::Vector3* offset);
	
	/**
	 *    Accessor for the rotation around the Z-axis that should be applied to the model upon creation
	 NOTE: this should probably be replaced with a Quaternion
	 * @return 
	 */
	float getRotation() ;
	void setRotation(float rotation);
	
	EmberOgre::Model::SubModelDefinition* createSubModelDefinition(std::string& meshname);
	std::vector<EmberOgre::Model::SubModelDefinition*>& getSubModelDefinitions();
	void removeSubModelDefinition(EmberOgre::Model::SubModelDefinition* def);
	
	EmberOgre::Model::ActionDefinition* createActionDefinition(std::string& actionname);
	std::vector<EmberOgre::Model::ActionDefinition*>& getActionDefinitions();
	void removeActionDefinition(EmberOgre::Model::ActionDefinition* def);
	
	
};

class ModelDefnPtr
{
	EmberOgre::Model::ModelDefinition* get();
};

typedef EmberOgre::Model::ModelDefnPtr ModelDefinitionPtr;

};
}
#endif
