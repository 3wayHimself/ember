? Makefile
? OgreMain.diff
? ogre_shared_skeleton.diff
? include/Makefile
? src/Makefile
Index: include/OgreAxisAlignedBox.h
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/include/OgreAxisAlignedBox.h,v
retrieving revision 1.17
diff -U3 -r1.17 OgreAxisAlignedBox.h
--- include/OgreAxisAlignedBox.h	7 Feb 2004 18:27:12 -0000	1.17
+++ include/OgreAxisAlignedBox.h	23 Aug 2004 06:11:33 -0000
@@ -31,6 +31,7 @@
 #include "OgreVector3.h"
 #include "OgreMatrix4.h"
 
+
 namespace Ogre {
 
     /** A 3D box aligned with the x/y/z axes.
Index: include/OgreEntity.h
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/include/OgreEntity.h,v
retrieving revision 1.44
diff -U3 -r1.44 OgreEntity.h
--- include/OgreEntity.h	22 Jul 2004 22:17:01 -0000	1.44
+++ include/OgreEntity.h	23 Aug 2004 06:11:33 -0000
@@ -72,6 +72,9 @@
         // Allow SceneManager full access
         friend class SceneManager;
         friend class SubEntity;
+    public:
+	typedef std::set<Entity*> EntitySet;
+    
     protected:
 
         /** Private constructor (instances cannot be created directly).
@@ -101,7 +104,7 @@
 
 
         /// State of animation for animable meshes
-        AnimationStateSet mAnimationState;
+        AnimationStateSet* mAnimationState;
 
         /// Shared class-level name for Movable type
         static String msMovableType;
@@ -133,8 +136,20 @@
         /// Records the last frame in which animation was updated
         unsigned long mFrameAnimationLastUpdated;
 
-        /// Perform all the updates required for an animated entity
+         /// Perform all the updates required for an animated entity
         void updateAnimation(void);
+
+        /// Records the last frame in which the bones was updated
+        /// It's a pointer because it can be shared between different entities with
+        /// a shared skeleton.
+        unsigned long *mFrameBonesLastUpdated;
+
+        /**
+        * A set of all the entities which shares a single SkeletonInstance.
+        * This is only created if the entity is in fact sharing it's SkeletonInstance with
+        * other Entities.
+        */
+        EntitySet* mSharedSkeletonEntities;
         
         /// Private method to cache bone matrices from skeleton
         void cacheBoneMatrices(void);
@@ -448,6 +463,30 @@
         /** Overridden from MovableObject */
         void _notifyAttached(Node* parent, bool isTagPoint = false);
 
+        /** Shares the SkeletonInstance with the supplied entity.
+        *   Note that in order for this to work, both entities must have the same
+        *   Skeleton.
+        */
+        void shareSkeletonInstanceWith(Entity* entity);
+        void _shareSkeletonInstanceWith(Entity* const entity);
+
+	
+        /** Stops sharing the SkeletonInstance with other entities.
+        */
+        void Entity::stopSharingSkeletonInstance();
+
+
+        /**
+        * Returns whether this entity shares it's SkeltonInstance with other entity instances.
+        */
+        inline bool sharesSkeletonInstance() const { return mSharedSkeletonEntities != NULL; }
+
+        /**
+        * Returns a pointer to the set of entities which share a SkeletonInstance.
+        * If this instance does not share it's SkeletonInstance with other instances NULL will be returned
+        */
+        inline const EntitySet* getSkeletonInstanceSharingSet() const { return mSharedSkeletonEntities; }
+
 
     };
 
Index: include/OgreMesh.h
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/include/OgreMesh.h,v
retrieving revision 1.44
diff -U3 -r1.44 OgreMesh.h
--- include/OgreMesh.h	16 Jul 2004 19:14:30 -0000	1.44
+++ include/OgreMesh.h	23 Aug 2004 06:11:34 -0000
@@ -270,9 +270,9 @@
             update the bounds for you, because it cannot necessarily read vertex data back from 
             the vertex buffers which this mesh uses (they very well might be write-only, and even
             if they are not, reading data from a hardware buffer is a bottleneck).
-
+            @param pad If true, a certain padding will be added to the bounding box to separate it from the mesh
         */
-        void _setBounds(const AxisAlignedBox& bounds);
+        void _setBounds(const AxisAlignedBox& bounds, bool pad = false);
 
         /** Manually set the bounding radius. 
         @remarks
Index: include/OgreMeshManager.h
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/include/OgreMeshManager.h,v
retrieving revision 1.17
diff -U3 -r1.17 OgreMeshManager.h
--- include/OgreMeshManager.h	21 Jul 2004 20:44:54 -0000	1.17
+++ include/OgreMeshManager.h	23 Aug 2004 06:11:34 -0000
@@ -332,6 +332,17 @@
         */
         static MeshManager* getSingletonPtr(void);
 
+	/*
+	*Gets the factor by which the bounding box of an entity is padded
+	*Default is 0.01
+	*/
+        Real MeshManager::getBoundsPaddingFactor(void);
+	
+	/*
+	*Gets the factor by which the bounding box of an entity is padded
+	*/
+        void MeshManager::setBoundsPaddingFactor(Real paddingFactor);
+
     protected:
         /** Utility method for tesselating 2D meshes.
         */
@@ -343,6 +354,9 @@
         void createPrefabPlane(void);
 
         bool mPrepAllMeshesForShadowVolumes;
+	
+	//the factor by which the bounding box of an entity is padded	
+	Real mBoundsPaddingFactor;
     };
 
 
Index: include/OgreOverlayManager.h
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/include/OgreOverlayManager.h,v
retrieving revision 1.17
diff -U3 -r1.17 OgreOverlayManager.h
--- include/OgreOverlayManager.h	8 May 2004 00:15:04 -0000	1.17
+++ include/OgreOverlayManager.h	23 Aug 2004 06:11:34 -0000
@@ -45,12 +45,15 @@
     {
     protected:
         typedef std::list<MouseMotionListener*> MouseMotionListenerList;
+        typedef std::list<MouseListener*> MouseListenerList; 
         EventDispatcher mEventDispatcher;
 		Overlay* mCursorLevelOverlay;
         bool mCursorGuiInitialised;
 		GuiContainer* mCursorGuiRegistered;
 		MouseMotionListener* mCursorListener;
         MouseMotionListenerList mMouseMotionListenerList;
+        MouseListenerList mMouseListenerList; 
+	
 
         void parseNewElement( DataChunk& chunk, String& elemType, String& elemName, 
             bool isContainer, Overlay* pOverlay, bool isTemplate, String templateName = String(""), GuiContainer* container = 0);
@@ -110,6 +113,10 @@
         void setCursorGui(GuiContainer* cursor);
         void addMouseMotionListener(MouseMotionListener* l);
         void removeMouseMotionListener(MouseMotionListener* l);
+        void addMouseListener(MouseListener* l); 
+        void removeMouseListener(MouseListener* l); 
+ 
+
         Real getMouseX() { return mEventDispatcher.getMouseX(); }
         Real getMouseY() { return mEventDispatcher.getMouseY(); }
         void setDragDrop(bool dragDropOn) { mEventDispatcher.setDragDrop(dragDropOn); }
Index: src/OgreEntity.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreEntity.cpp,v
retrieving revision 1.79
diff -U3 -r1.79 OgreEntity.cpp
--- src/OgreEntity.cpp	22 Jul 2004 22:17:00 -0000	1.79
+++ src/OgreEntity.cpp	23 Aug 2004 06:11:34 -0000
@@ -52,7 +52,9 @@
     {
 		mFullBoundingBox = new AxisAlignedBox;
         mNormaliseNormals = false;
-        mFrameAnimationLastUpdated = 0;
+        mFrameBonesLastUpdated = new unsigned long;
+	*mFrameBonesLastUpdated = 0;
+	mFrameAnimationLastUpdated = 0;
         mHardwareSkinning = false;
         mSkeletonInstance = 0;
     }
@@ -60,7 +62,8 @@
     Entity::Entity( const String& name, Mesh* mesh, SceneManager* creator) :
         mName(name),
         mMesh(mesh),
-        mCreatorSceneManager(creator)
+        mCreatorSceneManager(creator),
+	mSharedSkeletonEntities(NULL)
     {
 		mFullBoundingBox = new AxisAlignedBox;
         mHardwareSkinning = false;
@@ -99,9 +102,11 @@
 
 
         // Initialise the AnimationState, if Mesh has animation
+
+        mAnimationState = new AnimationStateSet();
         if (hasSkeleton())
         {
-            mesh->_initAnimationState(&mAnimationState);
+            mesh->_initAnimationState(mAnimationState);
             mNumBoneMatrices = mSkeletonInstance->getNumBones();
             mBoneMatrices = new Matrix4[mNumBoneMatrices];
             prepareTempBlendBuffers();
@@ -126,7 +131,9 @@
 		mMinMaterialLodIndex = 99;
 
 
-        mFrameAnimationLastUpdated = 0;
+        mFrameBonesLastUpdated = new unsigned long;
+	*mFrameBonesLastUpdated = 0;
+	mFrameAnimationLastUpdated = 0;
     }
     //-----------------------------------------------------------------------
     Entity::~Entity()
@@ -147,8 +154,6 @@
 			// Delete 
 			delete (*li);
 		}
-		if (mBoneMatrices)
-            delete [] mBoneMatrices;
 
 		delete mFullBoundingBox;
 
@@ -159,9 +164,24 @@
         {
             delete *si;
         }
-        // Delete skeleton instance
-        if (mSkeletonInstance)
-            delete mSkeletonInstance; 
+	    
+	if (mSkeletonInstance) {
+		if (mSharedSkeletonEntities) {
+			mSharedSkeletonEntities->erase(this);
+			if (mSharedSkeletonEntities->size() == 0) {
+				delete mSkeletonInstance;
+				delete [] mBoneMatrices;
+				delete mAnimationState;
+				delete mFrameBonesLastUpdated;
+				delete mSharedSkeletonEntities;
+			}	
+		} else {
+			delete mSkeletonInstance;
+			delete [] mBoneMatrices;
+			delete mAnimationState;
+			delete mFrameBonesLastUpdated;
+		}
+	}
     }
     //-----------------------------------------------------------------------
     Mesh* Entity::getMesh(void)
@@ -205,7 +225,7 @@
         {
             newEnt->getSubEntity(n)->setMaterialName((*i)->getMaterialName());
         }
-        newEnt->mAnimationState = mAnimationState;
+        newEnt->mAnimationState = new AnimationStateSet(*mAnimationState);
         return newEnt;
     }
     //-----------------------------------------------------------------------
@@ -359,9 +379,9 @@
     //-----------------------------------------------------------------------
     AnimationState* Entity::getAnimationState(const String& name)
     {
-        AnimationStateSet::iterator i = mAnimationState.find(name);
+        AnimationStateSet::iterator i = mAnimationState->find(name);
 
-        if (i == mAnimationState.end())
+        if (i == mAnimationState->end())
         {
             Except(Exception::ERR_ITEM_NOT_FOUND, "No animation entry found named " + name, 
             "Entity::getAnimationState");
@@ -372,7 +392,7 @@
     //-----------------------------------------------------------------------
     AnimationStateSet* Entity::getAllAnimationStates(void)
     {
-        return &mAnimationState;
+        return mAnimationState;
     }
     //-----------------------------------------------------------------------
     const String& Entity::getMovableType(void) const
@@ -441,6 +461,10 @@
     //-----------------------------------------------------------------------
     void Entity::cacheBoneMatrices(void)
     {
+       Root& root = Root::getSingleton();
+       unsigned long currentFrameNumber = root.getCurrentFrameNumber();		
+       if (*mFrameBonesLastUpdated  != currentFrameNumber) {
+		
 		// Get the appropriate meshes skeleton here
 		// Can use lower LOD mesh skeleton if mesh LOD is manual
 		// We make the assumption that lower LOD meshes will have
@@ -464,26 +488,45 @@
 			theMesh = mMesh;
 		}
 	
-        mSkeletonInstance->setAnimationState(mAnimationState);
-        mSkeletonInstance->_getBoneMatrices(mBoneMatrices);
-		//--- Update the child object's transforms
-		ChildObjectList::iterator child_itr = mChildObjectList.begin();
-		ChildObjectList::iterator child_itr_end = mChildObjectList.end();
-		for( ; child_itr != child_itr_end; child_itr++)
-		{
-            (*child_itr).second->getParentNode()->_update(true, true);
+		mSkeletonInstance->setAnimationState(*mAnimationState);
+		mSkeletonInstance->_getBoneMatrices(mBoneMatrices);
+		*mFrameBonesLastUpdated  = currentFrameNumber;
+		
+		if (sharesSkeletonInstance()) {
+			//---- update all sharing entities child objects transforms now
+			EntitySet::const_iterator entity_itr = mSharedSkeletonEntities->begin();
+			EntitySet::const_iterator entity_itr_end = mSharedSkeletonEntities->end();
+			for( ; entity_itr != entity_itr_end; entity_itr++)
+			{
+				ChildObjectList::iterator child_itr = (*entity_itr)->mChildObjectList.begin();
+				ChildObjectList::iterator child_itr_end = (*entity_itr)->mChildObjectList.end();
+				for( ; child_itr != child_itr_end; child_itr++)
+				{
+				(*child_itr).second->getParentNode()->_update(true, true);
+				}
+			}
+		} else {
+			//--- Update the child object's transforms
+			ChildObjectList::iterator child_itr = mChildObjectList.begin();
+			ChildObjectList::iterator child_itr_end = mChildObjectList.end();
+			for( ; child_itr != child_itr_end; child_itr++)
+			{
+			(*child_itr).second->getParentNode()->_update(true, true);
+			}
 		}
 		
-        // Apply our current world transform to these too, since these are used as
-        // replacement world matrices
+		// Apply our current world transform to these too, since these are used as
+		// replacement world matrices
 		unsigned short i;
-        Matrix4 worldXform = _getParentNodeFullTransform();
+		Matrix4 worldXform = _getParentNodeFullTransform();
 		mNumBoneMatrices = mSkeletonInstance->getNumBones();
-
-        for (i = 0; i < mNumBoneMatrices; ++i)
-        {
-            mBoneMatrices[i] = worldXform * mBoneMatrices[i];
-        }
+	
+		for (i = 0; i < mNumBoneMatrices; ++i)
+		{
+		mBoneMatrices[i] = worldXform * mBoneMatrices[i];
+		}
+       }
+		
 
     }
     //-----------------------------------------------------------------------
@@ -1102,5 +1145,77 @@
             }
         }
     }
+    
+    //-----------------------------------------------------------------------
+    void Entity::shareSkeletonInstanceWith(Entity* entity)
+    {
+        if (entity->getMesh()->getSkeleton() != getMesh()->getSkeleton()) {
+		Except(Exception::ERR_RT_ASSERTION_FAILED, 
+		"The supplied entity has a different skeleton.",
+		"Entity::shareSkeletonWith");	
+	}
+	if (!mSkeletonInstance) {
+		Except(Exception::ERR_RT_ASSERTION_FAILED, 
+		"This entity has no skeleton.",
+		"Entity::shareSkeletonWith");	
+	}	
+	if (mSharedSkeletonEntities != NULL && entity->mSharedSkeletonEntities != NULL) {
+		Except(Exception::ERR_RT_ASSERTION_FAILED, 
+		"Both entities already shares their SkeletonInstances! Atleast one of the instances must not share it's instance.",
+		"Entity::shareSkeletonWith");	
+	}	
+	_shareSkeletonInstanceWith(entity);
+	
+	//reevaluateVertexProcessing();
+    }
 
+
+	void Entity::_shareSkeletonInstanceWith(Entity* const entity)
+	{
+		//check if we already share our skeletoninstance, we don't want to delete it if so
+		if (mSharedSkeletonEntities != NULL) {
+			entity->shareSkeletonInstanceWith(this);
+		} else {
+			delete mSkeletonInstance;
+			delete mBoneMatrices;
+			delete mAnimationState;
+			delete mFrameBonesLastUpdated;
+			mSkeletonInstance = entity->mSkeletonInstance;
+			mNumBoneMatrices = entity->mNumBoneMatrices;
+			mBoneMatrices = entity->mBoneMatrices;
+			mAnimationState = entity->mAnimationState;
+			mFrameBonesLastUpdated = entity->mFrameBonesLastUpdated;
+			if (entity->mSharedSkeletonEntities == NULL) {
+				entity->mSharedSkeletonEntities = new EntitySet();
+				entity->mSharedSkeletonEntities->insert(entity);
+			}
+			mSharedSkeletonEntities = entity->mSharedSkeletonEntities;
+			mSharedSkeletonEntities->insert(this);
+		}
+	}    
+	
+	void Entity::stopSharingSkeletonInstance()
+	{
+		if (mSharedSkeletonEntities == NULL) {
+			Except(Exception::ERR_RT_ASSERTION_FAILED, 
+			"This entity is not sharing it's skeletoninstance.",
+			"Entity::shareSkeletonWith");	
+		}	
+		//check if there's no other than we sharing the skeleton instance
+		if (mSharedSkeletonEntities->size() == 1) {
+			//just reset
+			delete mSharedSkeletonEntities;
+		} else {
+			//do some cloning
+			mSkeletonInstance = new SkeletonInstance(*mSkeletonInstance);
+			mBoneMatrices = new Matrix4(*mBoneMatrices);
+			mAnimationState = new AnimationStateSet(*mAnimationState);
+			mFrameBonesLastUpdated = new unsigned long(*mFrameBonesLastUpdated);
+			mSharedSkeletonEntities->erase(this);
+			if (mSharedSkeletonEntities->size() == 1) {
+				(*mSharedSkeletonEntities->begin())->stopSharingSkeletonInstance();
+			}
+		}
+	}
+    
 }
Index: src/OgreMesh.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreMesh.cpp,v
retrieving revision 1.75
diff -U3 -r1.75 OgreMesh.cpp
--- src/OgreMesh.cpp	16 Jul 2004 19:14:31 -0000	1.75
+++ src/OgreMesh.cpp	23 Aug 2004 06:11:34 -0000
@@ -315,20 +315,28 @@
         return mAABB;
     }
     //-----------------------------------------------------------------------
-    void Mesh::_setBounds(const AxisAlignedBox& bounds)
+    void Mesh::_setBounds(const AxisAlignedBox& bounds, bool pad)
     {
         mAABB = bounds;
-        // Pad out the AABB a little, helps with most bounds tests
-        mAABB.setExtents(mAABB.getMinimum() - Vector3::UNIT_SCALE,
-        mAABB.getMaximum() + Vector3::UNIT_SCALE);
-
-		// Set sphere bouds; not the tightest by since we're using
-		// manual AABB it is the only way
-		Real sqLen1 = mAABB.getMinimum().squaredLength();
-		Real sqLen2 = mAABB.getMaximum().squaredLength();
-		mBoundRadius = Math::Sqrt(std::max(sqLen1, sqLen2)); 
-        // Pad out the sphere a little too
-        mBoundRadius = mBoundRadius + 1;
+	Vector3 max = mAABB.getMaximum();
+	Vector3 min = mAABB.getMinimum();
+	
+	// Set sphere bounds; not the tightest by since we're using
+	// manual AABB it is the only way
+	Real sqLen1 = min.squaredLength();
+	Real sqLen2 = max.squaredLength();
+	
+	mBoundRadius = Math::Sqrt(std::max(sqLen1, sqLen2)); 
+	if (pad) {
+		// Pad out the AABB a little, helps with most bounds tests
+		Vector3 scaler = (max - min) * MeshManager::getSingleton().getBoundsPaddingFactor();
+        	mAABB.setExtents(min  - scaler, max + scaler);
+	        // Pad out the sphere a little too
+	        mBoundRadius = mBoundRadius + (mBoundRadius * MeshManager::getSingleton().getBoundsPaddingFactor());
+	} else {
+        	mAABB.setExtents(min, max);
+	        mBoundRadius = mBoundRadius;
+	}
 		
         //mUpdateBounds = false;
     }
Index: src/OgreMeshManager.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreMeshManager.cpp,v
retrieving revision 1.19
diff -U3 -r1.19 OgreMeshManager.cpp
--- src/OgreMeshManager.cpp	21 Jul 2004 20:44:53 -0000	1.19
+++ src/OgreMeshManager.cpp	23 Aug 2004 06:11:35 -0000
@@ -51,7 +51,8 @@
         assert( ms_Singleton );  return ( *ms_Singleton );  
     }
     //-----------------------------------------------------------------------
-    MeshManager::MeshManager()
+    MeshManager::MeshManager():
+    mBoundsPaddingFactor(0.01)
     {
         mPrepAllMeshesForShadowVolumes = false;
 
@@ -250,7 +251,7 @@
         tesselate2DMesh(pSub, xsegments + 1, ysegments + 1, false, indexBufferUsage, indexShadowBuffer);
 
         //pMesh->_updateBounds();
-        pMesh->_setBounds(AxisAlignedBox(min, max));
+        pMesh->_setBounds(AxisAlignedBox(min, max), true);
         pMesh->_setBoundingSphereRadius(Math::Sqrt(maxSquaredLength));
         // load
         pMesh->load();
@@ -411,7 +412,7 @@
         tesselate2DMesh(pSub, xsegments + 1, ysegments + 1, 
 			false, indexBufferUsage, indexShadowBuffer);
 
-        pMesh->_setBounds(AxisAlignedBox(min, max));
+        pMesh->_setBounds(AxisAlignedBox(min, max), true);
 		pMesh->_setBoundingSphereRadius(Math::Sqrt(maxSqLen));
 
         pMesh->load();
@@ -606,7 +607,7 @@
             indexBufferUsage, indexShadowBuffer);
 
         //pMesh->_updateBounds();
-        pMesh->_setBounds(AxisAlignedBox(min, max));
+        pMesh->_setBounds(AxisAlignedBox(min, max), true);
         pMesh->_setBoundingSphereRadius(Math::Sqrt(maxSquaredLength));
         pMesh->load();
         pMesh->touch();
@@ -753,7 +754,7 @@
 		sub->indexData->indexStart =0;
         ibuf->writeData(0, ibuf->getSizeInBytes(), faces, true);
 
-        msh->_setBounds(AxisAlignedBox(-100,-100,0,100,100,0));
+        msh->_setBounds(AxisAlignedBox(-100,-100,0,100,100,0), true);
         msh->_setBoundingSphereRadius(Math::Sqrt(100*100+100*100));
 
         mResources[msh->getName()] = msh;
@@ -793,6 +794,16 @@
         return mPrepAllMeshesForShadowVolumes;
     }
     //-----------------------------------------------------------------------
+    Real MeshManager::getBoundsPaddingFactor(void)
+    {
+        return mBoundsPaddingFactor;
+    }
+    //-----------------------------------------------------------------------
+    void MeshManager::setBoundsPaddingFactor(Real paddingFactor)
+    {
+        mBoundsPaddingFactor = paddingFactor;
+    }
+    //-----------------------------------------------------------------------
 
 
 }
Index: src/OgreMeshSerializerImpl.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreMeshSerializerImpl.cpp,v
retrieving revision 1.16
diff -U3 -r1.16 OgreMeshSerializerImpl.cpp
--- src/OgreMeshSerializerImpl.cpp	16 Jul 2004 19:14:31 -0000	1.16
+++ src/OgreMeshSerializerImpl.cpp	23 Aug 2004 06:11:35 -0000
@@ -1130,7 +1130,7 @@
         readReals(chunk, &max.y, 1);
         readReals(chunk, &max.z, 1);
         AxisAlignedBox box(min, max);
-        mpMesh->_setBounds(box);
+        mpMesh->_setBounds(box, true);
         // Real radius
         Real radius;
         readReals(chunk, &radius, 1);
@@ -1553,14 +1553,14 @@
         
         if (mFirstGeometry)
         {
-            mpMesh->_setBounds(localBox);
+            mpMesh->_setBounds(localBox, true);
             mpMesh->_setBoundingSphereRadius(Math::Sqrt(maxSquaredRadius));
             mFirstGeometry = false;
         }
         else
         {
             localBox.merge(mpMesh->mAABB);
-            mpMesh->_setBounds(localBox);
+            mpMesh->_setBounds(localBox, true);
             maxSquaredRadius = std::max(maxSquaredRadius, mpMesh->mBoundRadius);
             mpMesh->_setBoundingSphereRadius(Math::Sqrt(maxSquaredRadius));
         }
Index: src/OgreOverlayManager.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreOverlayManager.cpp,v
retrieving revision 1.26
diff -U3 -r1.26 OgreOverlayManager.cpp
--- src/OgreOverlayManager.cpp	16 Jul 2004 19:14:31 -0000	1.26
+++ src/OgreOverlayManager.cpp	23 Aug 2004 06:11:35 -0000
@@ -577,6 +577,7 @@
     void OverlayManager::processEvent(InputEvent* e)
     {
         MouseMotionListenerList::iterator i, iEnd;
+	MouseListenerList::iterator il, ilEnd; 
 
         mEventDispatcher.dispatchEvent(e);
 
@@ -594,7 +595,21 @@
             for (i = mMouseMotionListenerList.begin(); i != iEnd; ++i)
                 (*i)->mouseDragged(static_cast<MouseEvent*>(e));
             break;
+	    
+	case MouseEvent::ME_MOUSE_PRESSED : 
+            ilEnd = mMouseListenerList.end(); 
+            for (il = mMouseListenerList.begin(); il != ilEnd; ++il) 
+            (*il)->mousePressed(static_cast<MouseEvent*>(e)); 
+            break; 
+ 
+        case MouseEvent::ME_MOUSE_RELEASED : 
+            ilEnd = mMouseListenerList.end(); 
+            for (il = mMouseListenerList.begin(); il != ilEnd; ++il) 
+            (*il)->mouseReleased(static_cast<MouseEvent*>(e)); 
+            break;
         }
+	
+	
     }
 
 	//-----------------------------------------------------------------------------
@@ -659,6 +674,27 @@
             }
     }
 
+     //-----------------------------------------------------------------------------
+    
+    void OverlayManager::addMouseListener(MouseListener* l) 
+    { 
+        mMouseListenerList.push_back(l); 
+    } 
+ 
+    //----------------------------------------------------------------------------- 
+    void OverlayManager::removeMouseListener(MouseListener* l) 
+    { 
+        MouseListenerList::iterator i, iEnd; 
+ 
+        iEnd = mMouseListenerList.end(); 
+        for (i = mMouseListenerList.begin(); i != iEnd; ++i) 
+        if (*i == l) 
+        { 
+            mMouseListenerList.erase(i); 
+            break; 
+        } 
+    } 
+
 	//-----------------------------------------------------------------------------
 	void OverlayManager::createCursorOverlay()
 	{
Index: src/OgrePatchMesh.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgrePatchMesh.cpp,v
retrieving revision 1.5
diff -U3 -r1.5 OgrePatchMesh.cpp
--- src/OgrePatchMesh.cpp	20 Dec 2003 12:48:46 -0000	1.5
+++ src/OgrePatchMesh.cpp	23 Aug 2004 06:11:35 -0000
@@ -93,7 +93,7 @@
         mSurface.build(vbuf, 0, sm->indexData->indexBuffer, 0);
 
         // Set bounds
-        this->_setBounds(mSurface.getBounds());
+        this->_setBounds(mSurface.getBounds(), true);
         this->_setBoundingSphereRadius(mSurface.getBoundingSphereRadius());
         mIsLoaded = true;
 
Index: src/OgreWireBoundingBox.cpp
===================================================================
RCS file: /cvsroot/ogre/ogrenew/OgreMain/src/OgreWireBoundingBox.cpp,v
retrieving revision 1.13
diff -U3 -r1.13 OgreWireBoundingBox.cpp
--- src/OgreWireBoundingBox.cpp	20 Dec 2003 12:48:46 -0000	1.13
+++ src/OgreWireBoundingBox.cpp	23 Aug 2004 06:11:35 -0000
@@ -105,15 +105,16 @@
         Real sqLen = std::max(vmax.squaredLength(), vmin.squaredLength());
         mRadius = Math::Sqrt(sqLen);
 		
-		// inflate the wire bounding box just a bit so that it will set apart from
-		//      a solid object
-		Real maxx = vmax.x + 1.0;
-		Real maxy = vmax.y + 1.0;
-		Real maxz = vmax.z + 1.0;
+
+		
+		
+		Real maxx = vmax.x;
+		Real maxy = vmax.y;
+		Real maxz = vmax.z;
 		
-		Real minx = vmin.x - 1.0;
-		Real miny = vmin.y - 1.0;
-		Real minz = vmin.z - 1.0;
+		Real minx = vmin.x;
+		Real miny = vmin.y;
+		Real minz = vmin.z;
 		
 		// fill in the Vertex buffer: 12 lines with 2 endpoints each make up a box
         HardwareVertexBufferSharedPtr vbuf =
