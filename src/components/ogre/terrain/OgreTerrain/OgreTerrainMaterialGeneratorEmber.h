/*
   Copyright (C) 2013 Samuel Kogler

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef OGRETERRAINMATERIALGENERATOREMBER_H
#define OGRETERRAINMATERIALGENERATOREMBER_H

#include <OgreTerrainMaterialGenerator.h>

namespace Ember
{
namespace OgreView
{
class IPageDataProvider;

namespace Terrain
{
/**
 * @brief A material generator that always uses the material generated by Ember.
 * Most parameters and settings are ignored.
 */
class OgreTerrainMaterialGeneratorEmber : public Ogre::TerrainMaterialGenerator
{
public:
	OgreTerrainMaterialGeneratorEmber(IPageDataProvider& dataProvider, Ogre::Real originX, Ogre::Real originZ);
	virtual ~OgreTerrainMaterialGeneratorEmber();

	/** Whether this generator can generate a material for a given declaration.
	        By default this only returns true if the declaration is equal to the
	        standard one returned from getLayerDeclaration, but if a subclass wants
	        to be flexible to generate materials for other declarations too, it
	        can specify here.
	 */
	virtual bool canGenerateUsingDeclaration(const Ogre::TerrainLayerDeclaration& decl)
	{
		// We are using our own materials so we don't care about the layer declaration.
		return true;
	}
	/** Return whether this material generator supports using a compressed
	        vertex format. This is only possible when using shaders.
	 */
	virtual bool isVertexCompressionSupported() const
	{
		// TODO SK: not supported for now
		return false;
	}
	/** Triggers the generator to request the options that it needs.
	 */
	virtual void requestOptions(Ogre::Terrain* terrain);

	/** Generate a material for the given terrain using the active profile.
	 */
	virtual Ogre::MaterialPtr generate(const Ogre::Terrain* terrain);
	/** Generate a material for the given composite map of the terrain using the active profile.
	 */
	virtual Ogre::MaterialPtr generateForCompositeMap(const Ogre::Terrain* terrain);
	/** Whether to support a light map over the terrain in the shader,
	   if it's present (default true).
	 */
	virtual void setLightmapEnabled(bool enabled)
	{
		// We don't use this.
	}
	/** Get the maximum number of layers supported with the given terrain.
	   @note When you change the options on the terrain, this value can change.
	 */
	virtual Ogre::uint8 getMaxLayers(const Ogre::Terrain* terrain) const
	{
		// We don't use this.
	}
	/** Update the composite map for a terrain.
	   The composite map for a terrain must match what the terrain should look like
	   at distance. This method will only be called in the render thread so the
	   generator is free to render into a texture to support this, so long as
	   the results are blitted into the Ogre::Terrain's own composite map afterwards.
	 */
	virtual void updateCompositeMap(const Ogre::Terrain* terrain, const Ogre::Rect& rect)
	{
		// We don't use this.
	}
	/** Update parameters for the given terrain.
	 */
	virtual void updateParams(const Ogre::MaterialPtr& mat, const Ogre::Terrain* terrain)
	{
		// TODO SK: we need this if we want to edit stuff I think.
	}
	/** Update parameters for the given terrain composite map using the active profile.
	 */
	virtual void updateParamsForCompositeMap(const Ogre::MaterialPtr& mat, const Ogre::Terrain* terrain)
	{
		// We don't use this.
	}
	/** Set the debug level of the material.
	   @remarks
	        Sets the level of debug display for this material.
	        What this debug level means is entirely depdendent on the generator,
	        the only constant is that 0 means 'no debug' and non-zero means
	        'some level of debugging', with any graduations in non-zero values
	        being generator-specific.
	 */
	virtual void setDebugLevel(unsigned int dbg)
	{
		// We don't use this.
	}
protected:
	IPageDataProvider& mDataProvider;
	Ogre::Real mOriginX;
	Ogre::Real mOriginZ;
};
} /* Terrain */
} /* OgreView */
} /* Ember */

#endif /* end of include guard: OGRETERRAINMATERIALGENERATOREMBER_H */
